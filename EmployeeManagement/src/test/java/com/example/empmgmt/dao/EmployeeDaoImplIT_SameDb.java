
package com.example.empmgmt.dao;

import com.example.empmgmt.entity.Employee;
import com.example.empmgmt.utility.DbUtil;
import org.junit.jupiter.api.*;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Integration tests that run against the SAME database.
 * Uses a single transactional connection per test (autoCommit=false),
 * and rolls back in @AfterEach so your real data is not altered.
 */
class EmployeeDaoImplIT_SameDb {

    private Connection con;
    private EmployeeDao dao;

    @BeforeEach
    void startTransactionAndSeed() throws SQLException {
        con = DbUtil.getConnection();
        con.setAutoCommit(false);   // begin transaction
        dao = new EmployeeDaoImpl(con);
        

        try (Statement st = con.createStatement()) {
            // Seed rows with recognizable prefix; rolled back at end of test
            st.execute("""
                INSERT INTO employees (ename, salary, location, designation) VALUES
                  ('TEST_Aarav', 75000.00, 'Bangalore', 'Engineer'),
                  ('TEST_Isha',  90000.00, 'Pune',      'Senior Developer'),
                  ('TEST_Rahul', 65000.00, 'Hyderabad', 'QA Engineer')
            """);
        }
    }

    @AfterEach
    void rollbackAndClose() throws SQLException {
        if (con != null) {
            con.rollback(); // undo all changes done in this test
            con.close();
        }
    }

    // ---------- getAllEmployees ----------
    @Test
    void getAllEmployees_positive_returnsSeededRows() {
        List<Employee> list = dao.getAllEmployees();
        assertNotNull(list, "List should not be null");
        assertTrue(list.stream().anyMatch(e -> e.getEname().startsWith("TEST_")),
                   "Seed rows with TEST_ should be present");
    }

    // ---------- addEmployee ----------
    @Test
    void addEmployee_positive_insertsAndGeneratesId() {
        Employee e = new Employee(0, "TEST_Neha", 82000.0, "Bangalore", "Analyst");
        Boolean ok = dao.addEmployee(e);

        assertTrue(Boolean.TRUE.equals(ok), "Add should return true");
        assertTrue(e.getEid() > 0, "eid should be generated by DB");

        List<Employee> list = dao.getAllEmployees();
        assertTrue(list.stream().anyMatch(emp -> "TEST_Neha".equals(emp.getEname())),
                   "Newly added TEST_Neha should be present");
    }

    @Test
    void addEmployee_negative_nullEmployeeReturnsFalseAndNoChange() {
        Boolean ok = dao.addEmployee(null);
        assertFalse(Boolean.TRUE.equals(ok), "Null Employee should return false");

        List<Employee> list = dao.getAllEmployees();
        long testCount = list.stream().filter(emp -> emp.getEname().startsWith("TEST_")).count();
        assertTrue(testCount >= 3, "Seed rows should remain; no extra insert occurred");
    }

    // ---------- updateEmployee ----------
    @Test
    void updateEmployee_positive_updatesExistingRow() {
        List<Employee> list = dao.getAllEmployees();
        assertFalse(list.isEmpty(), "Seed list should not be empty");
        Employee first = list.stream().filter(e -> e.getEname().startsWith("TEST_")).findFirst().orElseThrow();

        double newSalary = first.getSalary() + 5000.0;
        first.setSalary(newSalary);
        first.setDesignation("Senior " + first.getDesignation());

        Boolean ok = dao.updateEmployee(first);
        assertTrue(Boolean.TRUE.equals(ok), "Update should return true");

        List<Employee> after = dao.getAllEmployees();
        Employee updated = after.stream()
                .filter(e -> e.getEid() == first.getEid())
                .findFirst()
                .orElseThrow();

        assertEquals(newSalary, updated.getSalary(), 0.0001, "Salary should be updated");
        assertTrue(updated.getDesignation().startsWith("Senior"), "Designation should be updated");
    }

    @Test
    void updateEmployee_negative_invalidIdReturnsFalse() {
        Employee fake = new Employee(-1, "TEST_X", 0.0, "", "NA");
        Boolean ok = dao.updateEmployee(fake);
        assertFalse(Boolean.TRUE.equals(ok), "Invalid id should return false");
    }

    @Test
    void updateEmployee_negative_nonExistingIdReturnsFalse() {
        Employee e = new Employee(999999, "TEST_NoOne", 50000.0, "Nowhere", "None");
        Boolean ok = dao.updateEmployee(e);
        assertFalse(Boolean.TRUE.equals(ok), "Non-existent id should return false");
    }

    // ---------- deleteEmployee (returns updated list) ----------
    @Test
    void deleteEmployee_positive_existingIdRemovesRowAndReturnsUpdatedList() {
        List<Employee> before = dao.getAllEmployees();
        int idToDelete = before.stream().filter(e -> e.getEname().startsWith("TEST_"))
                               .findFirst().orElseThrow().getEid();

        List<Employee> after = dao.deleteEmployee(idToDelete);
        assertEquals(before.size() - 1, after.size(), "List size should decrease by 1");
        assertTrue(after.stream().noneMatch(e -> e.getEid() == idToDelete),
                   "Deleted id should not be present in updated list");
    }

    @Test
    void deleteEmployee_negative_nonExistingIdReturnsSameListSize() {
        List<Employee> before = dao.getAllEmployees();
        List<Employee> after = dao.deleteEmployee(999999);
        assertEquals(before.size(), after.size(), "Size should remain same for non-existent id");
    }

    @Test
    void deleteEmployee_negative_invalidIdReturnsSameListSize() {
        List<Employee> before = dao.getAllEmployees();
        List<Employee> after = dao.deleteEmployee(-1);
        assertEquals(before.size(), after.size(), "Size should remain same for invalid id");
    }
}

